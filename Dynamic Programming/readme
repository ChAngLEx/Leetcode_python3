适用DP的场景
1.求最值(max/min)
2.求方案总数(sum)
3.求可行性(or)


不适用DP的场景
1. 求所有具体的方案(最坏情况下用了DP也没有优化效果) 
2. 输入数据无序(除了背包类)
3. 暴力算法时间复杂度已经多项式级别(2^n → n^2)

#########################################
记忆化搜索的优化方案:
1.用word break的思路,使用is_possible[i],代表从i开始的后缀是否能够被break
在DFS找所有方案的时候,通过is_possible可以进行可行性剪枝

2.直接使用memo[i]记录从位置i开始的后缀
能够被break出来的所有方案

极端情况
以上两种方法在极端情况下是否能有优化效果呢?
答案:不能;eg:s = “aaaaaaaaaa...” dict = {“a”, “aa”, “aaa”, ...}

#########################################
解决动态规划问题的步骤
1.判断是否采用动态规划
2.归类属于哪一型动态规划
3.按照动规四要素解题:状态，方程，初始化，答案

动规的状态 State —— 递归的定义
- 用 f[i] 或者 f[i][j] 代表在某些特定条件下某个规模更小的问题的答案
- 规模更小用参数 i,j 之类的来划定

动规的方程 Function —— 递归的拆解 
- 大问题如何拆解为小问题
- f[i][j] = 通过规模更小的一些状态求 max / min / sum / or 来进行推导 

动规的初始化 Initialize —— 递归的出口
- 设定无法再拆解的极限小的状态下的值 
- 如 f[i][0] 或者 f[0][i]

动规的答案 Answer —— 递归的调用 
- 最后要求的答案是什么
- 如 f[n][m] 或者 max(f[n][0], f[n][1] ... f[n][m])

#########################################
分类:
坐标型
- 二维坐标 - 一维坐标(接龙) 
序列型
- 单序列型 - 双序列型 - 划分型
背包型 
区间型 

博弈型 
树型 
状态压缩型
#########################################
1.坐标型动态规划
状态:坐标 
方程:根据移动规则 
初始化:第0行第0列 
答案:目标坐标

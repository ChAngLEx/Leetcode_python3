适用DP的场景
1.求最值(max/min)
2.求方案总数(sum)
3.求可行性(or)


不适用DP的场景
1.求所有的具体方案
2.输入数据的无序
3.暴力算法时间复杂度已经是多项式级别(n^2/n^3)


记忆化搜索的优化方案:
1.用word break的思路,使用is_possible[i],代表从i开始的后缀是否能够被break
在DFS找所有方案的时候,通过is_possible可以进行可行性剪枝

2.直接使用memo[i]记录从位置i开始的后缀
能够被break出来的所有方案


极端情况
以上两种方法在极端情况下是否能有优化效果呢?
答案:不能;eg:s = “aaaaaaaaaa...” dict = {“a”, “aa”, “aaa”, ...}
